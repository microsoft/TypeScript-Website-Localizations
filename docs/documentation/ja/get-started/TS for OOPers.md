---
title: Java/C# プログラマのための TypeScript
short: Java/C# プログラマのための TS
layout: docs
permalink: /ja/docs/handbook/typescript-in-5-minutes-oop.html
oneline: オブジェクト指向言語のバックグラウンドから TypeScript を学ぶ
---

TypeScript は、C# や Java といった静的型付けを持つ他の言語に慣れているプログラマに人気の選択肢です。

TypeScript の型システムには、コードの補完性の向上、エラーの早期発見、プログラムの各部分間のコミュニケーションの明確化など、多くの利点があります。
TypeScript は C#や Java の開発者にとってはおなじみの機能を多く提供していますが、JavaScript(そして、それ故に TypeScript)が従来のオブジェクト指向プログラミング言語とどのように異なるのか、一歩引いて見てみる価値があります。
これらの違いを理解することで、より良い JavaScript コードを書くことができ、C#/Java から TypeScript に直行するプログラマが陥りがちな落とし穴を避けることができます。

## JavaScript との相互学習

JavaScript にはすでに慣れているが、本来 Java や C# のプログラマである場合、本入門ページは陥りやすいよくある誤解や落とし穴について理解する助けになるでしょう。
TypeScript が型をモデル化する方法の中には、Java や C# とは全く異なるものがあり、TypeScript を学ぶ際にはこうした点に留意しておくことが重要です。

あなたが Java や C# のプログラマで、全般的に JavaScript に不慣れである場合は、JavaScript の実行時の動作を理解するために型の _ない_ JavaScript を最初に少しだけ学ぶことをおすすめします。
TypeScript はコードの _動作_ を変更しないため、実際に何かを行うコードを書くためには、やはり JavaScript がどのように動作するのかについて学ぶ必要があるからです！

TypeScript は JavaScript と同じ _ランタイム_ を使用しているため、特定の実行時の動作(文字列を数値に変換する、アラートを表示する、ファイルをディスクに書き込むなど)を実現する手段はどんなものでも、常に TypeScript プログラムにも等しく適用されるということを覚えておくことが重要です。
TypeScript 特有の方法に思考を制限しないようにしましょう！

## クラスの再考

C# と Java は、_強制オブジェクト指向プログラミング_ 言語と呼ばれるものです。
これらの言語では、 _クラス_ はコード編成の基本的な単位であり、すべてのデータ _および_ 実行時の動作の基本的なコンテナでもあります。
すべての機能とデータを強制的にクラスに保持させることは、問題を解決するためには適したドメインモデルとなることもありますが、すべてのドメインがこのように表現される _必要_ はありません。

### 自由関数とデータ

JavaScript では、関数はどこにでも存在できますし、また、データは事前に定義された`class`や`struct`の中に入ることなく、自由に渡すことができます。
この柔軟性は非常に強力です。
"自由"関数(クラスに関連付けられていない関数)は、暗黙的なオブジェクト指向プログラミングの階層構造を持たないデータ上で動作するため、JavaScript でプログラムを記述する際には多くのケースで好ましいモデルとなります。

### 静的クラス

さらに、シングルトンや静的クラスといった C# と Java の構造体は TypeScript では不要です。

## TypeScript でのオブジェクト指向プログラミング

とは言え、クラスを使用することもできます。
伝統的なオブジェクト指向プログラミングの階層構造で解決するのに適した問題もあり、TypeScript の JavaScript クラスのサポートにより、こうしたモデルをさらに強力なものになります。
TypeScript は、インターフェースの実装や静的メソッドなどの多くの一般的なパターンをサポートします。

クラスについては本ガイドの後半で説明します。

## 型の再考

TypeScript における _型_ の理解は、C# や Java のそれとは実際大きく違います。
いくつか違いを探ってみましょう。

### 名目具体化型システム

C# や Java では、与えられた値やオブジェクトは`null`、プリミティブ、あるいは既知のクラス型のいずれかの厳密な型を持ちます。
`value.GetType()`や`value.getClass()`といったメソッドを呼び出し、実行時にその厳密な型を問い合わせることができます。
この型の定義はある名前でクラスのどこかに存在しており、明示的な継承関係あるいは共通に実装されたインターフェースがない限り、似たような形をしていようとも 2 つのクラスをお互いに代用して使うことができません。

これは _具体化、名目的_ 型システムの特徴を表しています。
コードに記述した型はランタイムに存在し、型は構造体ではなく宣言を通して関連付けられています。

### 集合体としての型

C# や Java では、ランタイムの型とコンパイル時の宣言の間に一対一の対応関係があると考えることに意味があります。

TypeScript では、型は何かしらの共通点がある _値の集合体_ として考える方が良いでしょう。
型は単なる集合体なので、特定の値は同時に _多くの_ 集合に属することができます。

型を集合体と考えるようになると、特定の操作がとても自然に受け入れられるようになります。
例えば、C# では、`string`や`int`のうち _どちらか_ である値を渡すのは不自然です。なぜならこの種の値を表す単一の型が存在しないからです。

TypeScript では、すべての型は単なる集合体であると理解すると、この操作はとても自然なことになります。
では、`string`の集合あるいは`number`の集合、どちらかに属する値はどのように記述すれば良いでしょう？
この値は単に 2 つの集合の _Union_ (`string | number`)に属しています。

TypeScript は、集合理論的な方法で型を扱うメカニズムを多く提供しており、型を集合であると考えると、直感的に使用できるようになるでしょう。

### 削除される構造的型

TypeScript では、オブジェクトは単一の厳密な型では _ありません_。
例えば、あるインターフェースを満たすオブジェクトを構築した場合、2 つの間に宣言的な関係がなかったとしても、そのインターフェースが期待される場所でオブジェクトを使用することができます。

```ts twoslash
interface Pointlike {
  x: number;
  y: number;
}
interface Named {
  name: string;
}

function logPoint(point: Pointlike) {
  console.log("x = " + point.x + ", y = " + point.y);
}

function logName(x: Named) {
  console.log("Hello, " + x.name);
}

const obj = {
  x: 0,
  y: 0,
  name: "Origin",
};

logPoint(obj);
logName(obj);
```

TypeScript の型システムは _構造的_ であり名目的ではありません。つまり、`obj`は`x`と`y`プロパティを持ち、どちらも数値であるため、`Pointlike`として使用することができます。
型と型の関係は、特定の関係で宣言されたかどうかではなく、それらの型に含まれる含まれるプロパティによって決定されます。

TypeScript の型システムは、_具体化的_ でもありません。実行時に`obj`が`Pointlike`であることを教えてくれるものは何もありません。
実際に、`Pointlike`型は実行時には _どのような形でも_ 存在することはありません。

_集合としての型_ という考えに戻ると、`obj`は`Pointlike`という値の集合と`Named`という値の集合の両方の構成要素であると考えることができます。

### 構造的型付けの結果

オブジェクト指向のプログラマは、構造的型付けの 2 つの独特な側面にしばしば驚かされます。

#### 空の型

1 つ目は _空の型_ が予想に反しているように見えることです:

```ts twoslash
class Empty {}

function fn(arg: Empty) {
  // 何かを行う
}

// エラーが出ませんが、これは'Empty'ではないのでは？
fn({ k: 10 });
```

TypeScript は、与えられた引数が有効な`Empty`であるかどうか調べることで、ここでの`fn`の呼び出しが有効なものかどうかを判断します。
これは、`{ k: 10 }`と`class Empty { }`の _構造_ を調べることで分かります。
`Empty`にはプロパティがないため、`{ k: 10 }`は`Empty`が持つプロパティを _すべて_ 持っていると考えることができます。
したがって、これは有効な呼び出しとなるのです！

これは驚くことに思えるかもしれませんが、結果的には名目オブジェクト指向のプログラミング言語で強制されるものと非常によく似ています。
部分型は基底クラスのプロパティを _削除_ することはできません。というのも、そうしてしまうと派生クラスは基底クラスの部分型であるという当たり前の関係を壊してしまうからです。
構造的型システムは、互換性のある型のプロパティを持つという観点から部分型を記述することで、この関係を暗黙的に確認しています。

#### 一致する型

もう一つのよくある驚きの原因は型同士が一致することによるものです:

```ts
class Car {
  drive() {
    // 車を飛ばす
  }
}
class Golfer {
  drive() {
    // ボールを遠くまで飛ばす
  }
}

// エラーにならない？
let w: Car = new Golfer();
```

繰り返しになりますが、これらのクラスの _構造体_ は同じなのでエラーになりません。
混乱のもとになりそうだと思うかもしれませんが、実際には関連するはずのないクラスが一致することは一般的ではありません。

クラスがどのように相互に関連しているのかについては、クラスの章で詳しく学びます。

### リフレクション

オブジェクト指向のプログラマは、ジェネリクスであっても任意の値の型を問い合わせることができることに馴染みがあります。

```csharp
// C#
static void LogType<T>() {
    Console.WriteLine(typeof(T).Name);
}
```

TypeScript の型は完全に消去されるので、ジェネリクスの型パラメータのインスタンス化などの情報は実行時には利用できません。

JavaScript には`typeof`と`instanceof`のような限定的なプリミティブがありますが、これらの演算子は型が削除された出力コードに存在する値を扱うことに注意してください。
例えば、`typeof (new Car())`は、`"object"`となり、`Car`や`"Car"`とはなりません。

---

本ガイドは概要です。ここから[ハンドブック](/docs/handbook/intro.html)や[Playground 例](/play#show-examples)に進んでみてください。
